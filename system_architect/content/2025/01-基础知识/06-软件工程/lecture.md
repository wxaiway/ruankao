# 软件工程讲义

## 课程内容提要

软件工程是以工程化的思想来开发软件，聚焦软件部分（区别于系统工程的软件、硬件、网络全面覆盖）。

主要内容包括：
- 软件过程模型
- 基于构件的软件工程(★★)
- 逆向工程(★)
- 净室软件工程(★)
- 需求工程(★★)
- 系统分析与设计(★★)
- 软件测试(★★)
- 系统运行与软件维护(★)

---

## 第一部分：软件过程模型

### 1. 软件过程模型概述

软件过程模型是遵循开发方法思想，进一步落地的解决方案。开发方法比模型要大一号，开发模型是遵循开发方法的思想，然后进一步落地的解决方案。

主要模型包括：
- ✓ 瀑布模型
- ✓ V模型【瀑布变种】
- ✓ 原型模型
- ✓ 螺旋模型【原型+瀑布】
- ✓ 构件组装模型/基于构件的开发方法
- ✓ 快速应用开发RAD【瀑布+构件组装】
- ✓ 统一过程/统一开发方法
- ✓ 敏捷开发方法

### 2. 瀑布模型

瀑布模型在1970年代非常盛行，使用率最高时能达到90%，但成功率并不高。

#### 特点
- ✓ 严格区分阶段，每个阶段因果关系紧密相连
- ✓ 只适合需求明确的项目

#### 缺点
- 软件需求完整性、正确性难确定
- 严格串行化，很长时间才能看到结果
- 瀑布模型要求每个阶段一次性完全解决该阶段工作，这不现实

#### 开发流程
```
需求分析 → 软件设计 → 程序设计 → 编码实现 → 单元测试 → 集成测试 → 系统测试 → 运行维护
```

### 3. 原型模型

原型模型主要针对需求不明确的项目，适合需求不明确的项目。

#### 基本思想
利用简易系统获取需求，通过原型工具把系统界面做出来，让用户看到界面后能够识别问题并参与修正过程。

#### 两个阶段
1. **原型开发阶段**：构造简易系统获取需求
2. **目标软件开发阶段**：基于明确需求开发目标软件

#### 原型分类
- **抛弃型原型**：快速原型，用完即弃
- **演化型原型**：逐步演化成最终系统

![原型相关模型](/imgs/2025/foundation/06-software-engineering/prototype-related-models.jpg)

### 4. V模型

V模型强调测试贯穿于始终，是一种测试驱动模型。

#### 特点
- 测试贯穿于始终
- 测试计划提前编制
- 分阶段测试，测试计划提前

![V模型](/imgs/2025/foundation/06-software-engineering/v-model.jpg)

#### W模型
W模型是V模型的变种，强调：
- 测试和开发**并行进行**
- 开发过程一条线，测试过程一条线，两者齐头并进

![测试流程](/imgs/2025/foundation/06-software-engineering/testing-process.jpg)

### 5. 迭代与增量

#### 增量型
- 1块1块增补的过程
- 先把核心模块开发出来，再附属一个模块，再附属一个

#### 迭代型  
- 强调逐步进化
- 从粗糙到精化的过程
- 从出到精的一个过程

#### 增量与迭代结合
在很多应用场景中，既有增量也有迭代：
- **增量**：从3个模块增加到6个模块
- **迭代**：原来已做好的模块进行精化优化

### 6. 螺旋模型

螺旋模型以快速原型为基础+瀑布模型，考虑了风险问题。

#### 两大特点
1. **原型为基础加瀑布**：原型1通过一轮瀑布模型开发形成原型2，再形成原型3
2. **考虑风险问题**：单独设立风险分析阶段

#### 四个阶段
- 目标设定
- 风险分析  
- 开发和有效性验证
- 评审

### 7. 构件组装模型

构件组装模型基于预先开发的构件进行组装来完成软件开发。

#### 优点
- ✓ 易扩展、易重用、降低成本、安排任务更灵活

#### 缺点
- 构件设计要求经验丰富的架构师
- 设计不好的构件难重用
- 强调重用可能牺牲其他指标(如性能)
- 第三方构件质量难控制

#### 开发流程
1. 需求分析和定义
2. 设计构件组装
3. 建立构件库
4. 构建应用软件
5. 测试和发布

#### 构件标准
- CORBA
- Sun的J2EE
- Microsoft的DNA

#### 生活实例
- **方舱医院**：预制病房模块现场拼装
- **乐高积木**：标准颗粒拼出不同作品

![构件组装](/imgs/2025/foundation/06-software-engineering/component-assembly.jpg)

---

## 第二部分：基于构件的软件工程(CBSE)

### 1. CBSE概述

CBSE体现了**【购买而不是重新构造】**的哲学。

### 2. 构件特征

CBSE的构件应具备以下特征：

1. **可组装性**：所有外部交互必须通过公开定义的接口进行
2. **可部署性**：构件总是二进制形式的，能作为独立实体在平台上运行
3. **文档化**：用户根据文档判断构件是否满足需求
4. **独立性**：可以在无其他特殊构件的情况下进行组装和部署
5. **标准化**：符合某种标准化的构件模型

### 3. 构件组装方式

构件组装一般都要借助胶水代码，有三种组装方式：

#### 1. 顺序组装
按顺序调用已经存在的构件，可以用两个已经存在的构件来创造一个新的构件。

#### 2. 层次组装
被调用构件的"提供"接口必须和调用构件的"请求"接口兼容。

#### 3. 叠加组装
多个构件合并形成新构件，新构件整合原构件的功能，对外提供新的接口。

#### 组装不兼容问题
组装可能出现3种不兼容：
- 参数不兼容
- 操作不兼容  
- 操作不完备

---

## 第三部分：快速应用开发模型(RAD)

RAD是瀑布流程+构件化开发的结合。

### 特点
- 基于构件的开发
- 可视化开发
- 结构化思想但迅速完成系统构建

### 代表工具
- PowerBuilder (PB)
- Delphi

![RAD模型](/imgs/2025/foundation/06-software-engineering/rad-model.jpg)

---

## 第四部分：统一过程

统一过程(UP)是一种面向对象的方法论。

### 1. 三大特征

1. **用例驱动**：用例来推动整个系统开发
2. **以架构为中心**：强调架构设计的重要性
3. **增量迭代**：用增量与迭代来解决问题

### 2. 四个阶段

- **初始**：偏向于需求阶段
- **细化**：偏向于架构设计阶段，完成系统架构
- **构造**：偏向于具体实施，开发剩余构件并组装测试
- **移交**：移交给用户，进行Beta测试，制作产品发布版本

![统一过程阶段](/imgs/2025/foundation/06-software-engineering/unified-process-phases.jpg)

### 3. 九个核心工作流

统一过程是二维结构：
- **4个阶段**：初始、细化、构造、移交
- **9个核心工作流**：6个核心过程 + 3个支撑过程

#### 6个核心过程
- 业务建模
- 需求
- 分析设计
- 实现
- 测试
- 部署

#### 3个支撑过程
- 配置和变更管理
- 项目管理
- 环境

![统一过程详细](/imgs/2025/foundation/06-software-engineering/unified-process-detailed.jpg)

---

## 第五部分：敏捷方法

### 1. 敏捷方法产生背景

2000年前后，行业大佬发现传统方法论存在问题：
- 产出很多文档
- 过程过于繁杂
- 效率降低但软件品质没有更可控

### 2. 敏捷vs传统方法

| 传统软件开发方法 | 敏捷方法 |
|---|---|
| 预设性的 | 适应性的 |
| 以开发过程为本 | 以人为本 |
| 整体分阶段 | 增量迭代，小步快跑 |
| 适合大型项目 | 适合小型项目 |

### 3. 敏捷宣言

敏捷的四大价值观：
- **个体和交互**胜过过程和工具
- **可工作的软件**胜过大量的文档
- **客户合作**胜过合同谈判
- **响应变化**胜过遵循计划

### 4. 主要敏捷方法

#### 极限编程(XP)
**4大价值观**：
- **沟通**【加强面对面沟通】
- **简单**【不过度设计】
- **反馈**【及时反馈】
- **勇气**【接受变更的勇气】

**12条过程实践规则**：
简单设计、测试驱动、代码重构、结对编程、持续集成、现场客户、发行版本小型化、系统隐喻、代码集体所有制、规划策略、规范代码、40小时工作机制

#### SCRUM
- 侧重于项目管理
- 强调增量与迭代
- 产品负责人对接需求，形成产品待办列表
- 迭代周期1-4周，小步快跑

#### 其他敏捷方法
- **水晶方法**：提倡"机动性"的方法，针对不同项目有效的敏捷过程
- **特征驱动开发方法(FDD)**：认为有效软件开发需要3要素【人、过程、技术】
- **开放式源码**：开发人员地域分布很广【其他方法强调集中办公】
- **ASD方法**：核心是三个非线性、重叠的开发阶段：猜测、合作与学习
- **动态系统开发方法(DSDM)**：倡导以业务为核心

---

## 第六部分：逆向工程

### 1. 逆向工程概述

逆向工程是反其道而行之的工程方法：
- **正向工程**：计划→需求分析→设计→实施→产品→运行
- **逆向工程**：现有产品→分析→设计→新产品

![逆向工程](/imgs/2025/foundation/06-software-engineering/reverse-engineering.jpg)

### 2. 抽象层次

逆向工程有四个抽象层次（从低到高）：

#### 实现级（抽象度最低）
包括程序的抽象语法树、符号表、过程的设计表示

#### 结构级  
包括反映程序分量之间相互依赖关系的信息，例如调用图、结构图、程序和数据结构

#### 功能级
包括反映程序段功能及程序段之间关系的信息，例如数据和控制流模型

#### 领域级（抽象度最高）
包括反映程序分量或程序实体与应用领域概念之间对应关系的信息，例如实体关系模型

### 3. 相关概念

#### 重构/重组(Restructuring)
重构是指在**同一抽象级别**上**转换系统描述形式**

#### 设计恢复(Design recovery)
设计恢复是指借助工具从已有程序中抽象出有关数据设计、总体结构设计和过程设计等方面的信息。

#### 逆向工程(Reverse engineering)
逆向工程是分析程序，力图在比源代码更高抽象层次上建立程序的表示过程，逆向工程是设计的恢复过程。

#### 正向工程(Forward engineering)
正向工程是指不仅从现有系统中恢复设计信息，而且使用该信息去改变或重构现有系统，以改善其整体质量。

#### 再工程/重构工程(Re-engineering)
再工程是对现有系统的重新开发过程，包括逆向工程、新需求的考虑过程和正向工程三个步骤。

---

## 第七部分：净室软件工程

### 1. 净室概念

净室即无尘室、洁净室，是一个受控污染级别的环境。

### 2. 核心特点

- 使用盒结构规约(或形式化方法)进行分析和设计建模
- 强调将**正确性验证**，而不是测试，作为发现和消除错误的主要机制
- 使用统计的测试来获取认证被交付的软件的可靠性所必需的出错率信息

### 3. 技术手段

- ✓ **统计过程控制下的增量式开发**：控制迭代
- ✓ **基于函数的规范和设计**：盒子结构
  - 定义3种抽象层次：行为视图(黑盒)→有限状态机视图(状态盒)→过程视图(明盒)
- ✓ **正确性验证**：净室工程的核心
- ✓ **统计测试和软件认证**：使用统计学原理，总体太大时必须采用抽样方法

### 4. 缺点

- ✓ 太理论化，正确性验证的步骤比较困难且耗时
- ✓ 开发小组不进行传统的模块测试，这是不现实的
- ✓ 脱胎于传统软件工程，不可避免带有传统软件工程的一些弊端

---

## 第八部分：需求工程

需求工程包括**需求开发**和**需求管理**两大板块。

### 1. 需求工程阶段划分

#### 需求开发
- ✓ 需求获取
- ✓ 需求分析  
- ✓ 形成需求规格【形成SRS】
- ✓ 需求确认与验证【形成需求基线(经过评审的SRS)】

#### 需求管理
需求管理是对**需求基线**进行管理
- 变更控制
- 版本控制
- 需求跟踪
- 需求状态跟踪

### 2. 需求的定义

软件需求是指用户对系统在功能、行为、性能、设计约束等方面的期望。

### 3. 需求获取

需求获取有多种方法，各有特点：

| 方法 | 特点 |
|---|---|
| 用户面谈 | 1对1-3，有代表性的用户，了解主观想法，交互好。成本高，要有领域知识支撑。 |
| 联合需求计划(JRP) | 高度组织的群体会议，各方参与，了解想法，消除分歧，交互好，成本高。 |
| 问卷调查 | 用户多，无法一一访谈，成本低。 |
| 现场观察 | 针对较为复杂的流程和操作。 |
| 原型化方法 | 通过简易系统方式解决早期需求不确定问题。 |
| 头脑风暴法 | 一群人围绕新业务，发散思维，不断产生新的观点。 |

### 4. 需求分析

需求分析分为结构化需求分析和面向对象需求分析。

#### 结构化需求分析

建立三类模型：

**功能模型**：用DFD(数据流图)表示
- 加工：对数据进行处理的功能部件
- 数据流：连接线表示数据流动
- 外部实体：与系统交互但不属于系统的实体
- 数据存储：数据库、数据表等

![需求分析图](/imgs/2025/foundation/06-software-engineering/requirements-analysis-diagram.jpg)

**数据模型**：用ER图(实体关系图)表示
- 实体：系统中的对象，对应数据库表
- 关系：实体之间的联系
- 属性：实体的特征

![ER图示例](/imgs/2025/foundation/06-software-engineering/er-diagram-example.jpg)

![ER关系图](/imgs/2025/foundation/06-software-engineering/er-relationship-diagram.jpg)

**行为模型**：用状态转换图表示
- 描述系统的交互过程
- 表现状态之间的转换关系

**数据字典**：
- 对模型中抽象概念的详细描述
- 类似于字典的解释作用
- 配套功能模型、数据模型、行为模型使用

#### 面向对象需求分析(UML)

UML(统一建模语言)：平台无关、语言无关的建模工具。

**UML构造块**：

![UML构造块](/imgs/2025/foundation/06-software-engineering/uml-building-blocks.jpg)

**事物**：
- **结构事物**：最静态的部分，包括类、接口、协作、用例、活动类、构件和节点
- **行为事物**：代表时间和空间上的动作，包括消息、动作次序、连接
- **分组事物**：看成是个盒子，如包、构件
- **注释事物**：UML模型的解释部分，描述、说明和标注模型的元素

**关系**：连接事物的方式

**图**：表现事物集合的方式
- **静态图**：类图、对象图、构件图、部署图、包图等
- **动态图**：用例图、顺序图、活动图、状态图、通信图等

**规则**：
- 命名：为构造块命名  
- 范围：给一个名字以特定含义的语境
- 可见性：怎样使用或看见名字
- 完整性：事物如何正确、一致地相互联系
- 执行：运行或模拟动态模型的含义

### 5. 需求定义

需求定义有两种方法：

#### 严格定义方法
基于以下假设：
- ✓ 所有需求都能够被预先定义
- ✓ 开发人员与用户之间能够准确而清晰地交流
- ✓ 采用图形/文字可以充分体现最终系统

![需求定义对比](/imgs/2025/foundation/06-software-engineering/requirements-definition-comparison.jpg)

#### 原型方法
基于以下假设：
- ✓ 并非所有的需求都能在开发前被准确的说明
- ✓ 项目参加者之间通常都存在交流上的困难
- ✓ 需要实际的、可供用户参与的系统模型
- ✓ 有合适的系统开发环境
- ✓ 反复是完全需要和值得提倡的，需求一旦确定，就应遵从严格的方法

![原型方法假设](/imgs/2025/foundation/06-software-engineering/prototype-method-assumptions.jpg)

### 6. 需求确认与验证

需求确认与验证的目标是形成**需求基线**（经过评审的需求规格说明书）。

要求：
- 用户参与
- 开评审会或需求测试
- 用户签字确认
- 作为验收标准

### 7. 需求跟踪

需求跟踪通过需求跟踪矩阵实现，确保：
- 用户原始需求映射到软件需求
- 软件需求映射到设计元素、代码块、测试用例
- 支持正向跟踪和反向跟踪（双向跟踪）

![需求跟踪表](/imgs/2025/foundation/06-software-engineering/requirements-traceability-table.jpg)

### 8. 需求变更管理

需求变更管理过程：

1. 识别出问题
2. 问题分析和变更描述
3. 变更分析和成本计算
4. 变更实现

![需求变更管理流程](/imgs/2025/foundation/06-software-engineering/requirements-change-management-process.jpg)

详细步骤：
1. 明确问题
2. 提出书面变更申请
3. 判断变更需求类别
4. 评估变更影响
5. 判断变更紧急级别
6. 沟通确认
7. 明确变更方案
8. 审批执行
9. 版本控制

变更审批由CCB（变更控制委员会）负责，由甲方、乙方、第三方多方代表构成。

---

## 第九部分：软件系统建模

软件系统建模是软件开发中的重要环节，通过构建软件系统模型帮助系统开发人员理解系统、抽取业务过程和管理系统的复杂性。

![软件系统建模概述](/imgs/2025/foundation/06-software-engineering/software-system-modeling-overview.jpg)

### 建模方法分类

#### 1. 结构化建模方法
- 以过程为中心的技术
- 可用于分析现有系统以及定义新系统的业务需求
- 绘制的模型称为数据流图(DFD)
- 适合流程较为稳定的系统

#### 2. 信息工程建模方法(数据库建模方法)
- 以数据为中心，但过程敏感的技术
- 强调在分析和研究过程需求之前，首先研究和分析数据需求
- 创建的模型被称为实体联系图(ERD)
- 主要用于数据建模

#### 3. 面向对象建模方法
- 将"数据"和"过程"集成到被称为"对象"的结构中
- 消除了数据和过程的人为分离现象
- 创建的模型被称为对象模型
- 形成了面向对象的建模标准，即UML

![建模方法分类](/imgs/2025/foundation/06-software-engineering/modeling-method-classification.jpg)

---

## 第十部分：系统设计

系统设计包括界面设计、结构化设计、面向对象设计等多个维度。

### 1. 人机界面设计

#### 黄金三法则

![人机界面设计原则](/imgs/2025/foundation/06-software-engineering/human-interface-design-principles.jpg)

1. **置于用户的控制之下**
   - 不能强迫用户进入不必要或不希望的交互方式
   - 允许用户交互过程中被中断和撤销

2. **减少用户的记忆负担**
   - 界面的视觉布局应该尽量与真实世界保持一致
   - 使用隐喻和符号减少记忆负担

3. **保持界面的一致性**
   - 所有可视信息的组织需要按照统一的设计标准
   - 确保用户界面操作和使用的一致性

### 2. 结构化设计

![结构化设计概念](/imgs/2025/foundation/06-software-engineering/structured-design-concepts.jpg)

#### 概要设计vs详细设计
- **概要设计【外部设计】**：功能需求分配给软件模块，确定每个模块的功能和调用关系，形成模块结构图
- **详细设计【内部设计】**：为每个具体任务选择适当的技术手段和处理方法

#### 模块独立性原则
**高内聚低耦合**是结构化设计的核心原则。

**内聚类型**（从高到低）：

| 内聚类型 | 描述 |
|---|---|
| 功能内聚 | 完成一个单一功能，各个部分协同工作，缺一不可 |
| 顺序内聚 | 处理元素相关，而且必须顺序执行 |
| 通信内聚 | 所有处理元素集中在一个数据结构的区域上 |
| 过程内聚 | 处理元素相关，而且必须按特定的次序执行 |
| 时间内聚(瞬时内聚) | 所包含的任务必须在同一时间间隔内执行 |
| 逻辑内聚 | 完成逻辑上相关的一组任务 |
| 偶然内聚(巧合内聚) | 完成一组没有关系或松散关系的任务 |

**耦合类型**（从低到高）：

| 耦合类型 | 描述 |
|---|---|
| 非直接耦合 | 两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的 |
| 数据耦合 | 一组模块借助参数表传递简单数据 |
| 标记耦合 | 一组模块通过参数表传递记录信息(数据结构) |
| 控制耦合 | 模块之间传递的信息中包含用于控制模块内部逻辑的信息 |
| 外部耦合 | 一组模块都访问同一全局简单变量，而且不是通过参数表传递该全局变量的信息 |
| 公共耦合 | 多个模块都访问同一个公共数据环境 |
| 内容耦合 | 一个模块直接访问另一个模块的内部数据；一个模块不通过正常入口转到另一个模块的内部；两个模块有一部分程序代码重叠；一个模块有多个入口 |

#### 其他设计原则
- 保持模块大小适中
- 多扇入少扇出：
  - **扇入**：有多少个外部模块调用该模块（希望多，表示复用度高）
  - **扇出**：该模块调用多少个下层模块（希望少，减少依赖）
- 深度和宽度均不宜过高

#### 模块四要素
1. **输入和输出**：模块的输入来源和输出去向
2. **处理功能**：指模块把输入转换成输出所做的工作
3. **内部数据**：指仅供该模块本身引用的数据
4. **程序代码**：指用来实现模块功能的程序

### 3. 面向对象设计

![面向对象设计过程](/imgs/2025/foundation/06-software-engineering/object-oriented-design-process.jpg)

#### 类的分类

**边界类**：
- 机器接口：API接口、通信协议
- 人机交互：显示屏、窗体、打印机接口、用户界面、对话框、菜单、购物车、报表、二维码

**控制类**：
- 应用逻辑
- 业务逻辑  
- 数据访问逻辑
- 例：身份验证器

**实体类**：
- 数据存储
- 例：学员类、课程类

#### 面向对象设计原则

**单一职责原则**：设计目的单一的类

**开放-封闭原则**：对扩展开放，对修改封闭

![开闭原则](/imgs/2025/foundation/06-software-engineering/open-closed-principle.jpg)

**里氏(Liskov)替换原则**：子类可以替换父类

**依赖倒置原则**：要依赖于抽象，而不是具体实现；针对接口编程，不要针对实现编程

**接口隔离原则**：使用多个专门的接口比使用单一的总接口要好

**组合重用原则**：要尽量使用组合，而不是继承关系达到重用目的

**迪米特(Demeter)原则(最少知识原则)**：一个对象应当对其他对象有尽可能少的了解

![迪米特原则](/imgs/2025/foundation/06-software-engineering/law-of-demeter.jpg)

---

## 第十一部分：软件测试

### 1. 软件测试类型

软件测试分为动态测试和静态测试。

![软件测试分类](/imgs/2025/foundation/06-software-engineering/software-testing-classification.jpg)

#### 动态测试
通过运行程序发现错误，包括：
- 白盒测试【结构测试】：主要用于单元测试阶段
- 黑盒测试【功能测试】：主要用于集成测试、确认测试和系统测试阶段
- 灰盒测试：介于白盒和黑盒之间

#### 静态测试
采用人工和计算机辅助静态分析的手段对程序进行检测，包括：
- 桌面检查
- 代码审查
- 代码走查

![静态测试分析](/imgs/2025/foundation/06-software-engineering/static-testing-analysis.jpg)

**静态分析类型**：
- **控制流分析**：是否存在没有使用的语句/无法达到的语句/调用并不存在的子程序
- **数据流分析**：引用未定义的变量、对以前未使用的变量再次赋值
- **接口分析**：模块之间接口的一致性、子程序和函数之间的接口一致性、函数形参与实参的数量、顺序、类型的一致性
- **表达式分析**：括号不配对、数组引用越界、除数为零

### 2. 白盒测试与黑盒测试

#### 白盒测试
主要用于单元测试阶段，能够看到程序内部结构。

![白盒测试方法](/imgs/2025/foundation/06-software-engineering/white-box-testing-methods.jpg)

**主要方法**：
- 逻辑覆盖（语句覆盖最弱，路径覆盖最强）
- 数据流测试
- 程序变异测试

#### 黑盒测试
主要用于集成测试、确认测试和系统测试阶段，将程序看作黑匣子。

![黑盒测试技术](/imgs/2025/foundation/06-software-engineering/black-box-testing-techniques.jpg)

**主要方法**：
- **等价类划分**：不同等价类，揭示不同问题；有效等价类/无效等价类
- **边界值分析**：1<=x<=10，可取x的值为0、1、10和11作为测试数据
- **错误推测**：依靠测试人员的经验和直觉
- **判定表**：最适合描述在多个逻辑条件取值的组合所构成的复杂情况下，分别要执行哪些不同的动作
- **因果图**：根据输入条件与输出结果之间的因果关系来设计测试用例

### 3. 软件测试阶段

#### 测试阶段划分
- **单元测试**：依据【详细设计】，模块测试，模块功能、性能、接口等
- **集成测试**：依据【概要设计】，模块间的接口  
- **系统测试**：依据【需求文档】，包括功能测试、性能测试、验收测试、压力测试等
- **确认测试**：依据【需求文档】，验证软件与需求的一致性

确认测试包括：内部确认测试、Alpha测试、Beta测试、验收测试

#### 其他测试类型

| 其他测试 | 描述 |
|---|---|
| AB测试 | 多版本同时使用，利于收集各版本的用户反馈，评估出最好版本。故也算是一种【网页优化方法】 |
| Web测试 | Web系统测试与其他系统测试测试内容基本相同，只是测试重点不同。Web代码测试包括：源代码规则分析、链接测试、框架测试、表格测试、图形测试等方面。 |
| 链接测试 | 链接测试可分为3个方面：<br>1、测试所有链接是否按指示的那样确实链接到了该链接的页面。<br>2、测试所链接的页面是否存在。<br>3、保证Web应用系统上没有孤立的页面。 |
| 表单测试 | 验证服务器是否能正确保存这些数据，后台运行的程序能否正确解释和使用这些信息。测试提交操作的完整性。 |
| 回归测试 | 测试软件变更之后，变更部分的正确性和对变更需求的符合性。 |

### 4. 集成测试策略

![集成测试策略](/imgs/2025/foundation/06-software-engineering/integration-testing-strategies.jpg)

#### 一次性组装
风险高，一次性把所有模块组装在一起测试。

#### 增量式组装
测试全面，逐步组装测试：

**自顶向下集成测试**：
- 需要桩模块(stub)：模拟被测模块调用的下层模块
- 不需要驱动模块

**自底向上集成测试**：
- 需要驱动模块(driver)：模拟上层模块调用被测模块
- 不需要桩模块

**混合式集成测试**：
- 既需要驱动模块，也需要桩模块

### 5. 软件系统测试

系统测试包括多个方面：
- **功能测试**
- **性能测试**
- **健壮性测试**
- **用户界面测试**
- **安全性测试**
- **安装与反安装测试**

#### 性能测试类型

| 测试类型 | 描述 |
|---|---|
| 负载测试 | 各种工作负载下系统的性能 |
| 压力测试【测上限】 | 系统的瓶颈或不能接受的性能点 |
| 强度测试【测下限】 | 系统资源特别低的情况下运行 |
| 容量测试【并发测试】 | 同时在线的最大用户数 |
| 可靠性测试 | MTTF之类的参数 |

---

## 第十二部分：系统运行与软件维护

### 1. 遗留系统演化策略

根据技术含量和业务价值两个维度，遗留系统有四种演化策略：

- **淘汰**：低技术含量 + 低业务价值
- **继承**：低技术含量 + 高业务价值（重新开发，兼容功能模型和数据模型）
- **改造**：高技术含量 + 高业务价值（功能增强和数据模型改造）
- **集成**：高技术含量 + 低业务价值（解决信息孤岛问题）

### 2. 系统转换策略

![系统转换策略](/imgs/2025/foundation/06-software-engineering/system-conversion-strategies.jpg)

#### 直接转换
停掉现有系统，启动新系统。风险高。

#### 并行转换
老系统和新系统同时运行一段时间。稳妥但成本高。

#### 分段转换
现有系统分批切换到新系统。风险适中，成本适中。

### 3. 数据转换与迁移

![数据转换迁移](/imgs/2025/foundation/06-software-engineering/data-conversion-migration.jpg)

数据迁移过程：**ETL**
- **E (Extract)**：抽取
- **T (Transform)**：转换  
- **L (Load)**：装载

可以事前通过工具迁移，也可以事前手工录入，或切换后系统导入/生成。

### 4. 软件维护类型

#### 正确性维护【修BUG】
识别和纠正软件错误/缺陷，测试不可能发现所有错误。

#### 适应性维护【应变】
指使应用软件适应环境变化【外部环境、数据环境】而进行的修改。

#### 完善性维护【新需求】
扩充功能和改善性能而进行的修改。

#### 预防性维护【针对未来】
为了适应未来的软硬件环境的变化，应主动增加预防性的新的功能，以使系统适应各类变化而不被淘汰。经典实例：【专用】改【通用】。

---

## 课程总结

软件工程作为一门以工程化思想指导软件开发的学科，涵盖了从需求分析到系统维护的完整生命周期。通过学习各种软件过程模型、开发方法、设计原则和测试策略，我们能够更好地理解和应用软件工程的理论与实践。

主要知识点回顾：
1. **软件过程模型**：从瀑布到敏捷的演进历程
2. **构件化开发**：提高重用性和开发效率
3. **需求工程**：确保软件满足用户期望的关键环节
4. **系统设计**：从结构化到面向对象的设计方法
5. **软件测试**：保证软件质量的重要手段
6. **系统维护**：确保软件持续可用的必要工作

软件工程的核心理念是将工程化的方法应用于软件开发，通过规范化的过程、科学的方法和有效的管理，提高软件开发的质量和效率。