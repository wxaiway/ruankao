#### **第一章：软件架构核心概念**

##### **1.1 软件架构的定义与作用**

软件架构是软件系统高层次的蓝图，它弥合了业务需求与技术实现之间的鸿沟。

*   **核心定义**：软件架构为系统提供了一个**结构、行为和属性的高级抽象**。
    > **关键考点**：架构由一组**词汇表**（构件、连接件等元素）和一组**约束**（元素如何组合的规则）组成。
*   **架构的本质**：
    *   架构设计是一种高层设计，发生在详细设计之前。
    *   架构设计可以被视为**需求分配**的过程，它将复杂的需求分解并分配到不同的构件上，从而简化问题。
*   **架构的作用**：
    *   **沟通媒介**：作为项目干系人（技术与非技术人员）之间进行交流的有效手段。例如，提及“B/S架构”、“微服务架构”就能快速传达系统的基本形态。
    *   **决策载体**：在设计变更相对容易的早期阶段，对系统的结构、技术选型等做出关键决策。
    *   **质量预测**：通过分析架构，可以预测软件的质量属性（如性能、可维护性等）。
    *   **复用模型**：架构本身（尤其是架构风格）是可传递和可复用的。

---

#### **第二章：基于架构的软件开发**

##### **2.1 4+1视图模型**

为了从不同角度全面地理解和描述复杂的软件架构，`Philippe Kruchten`提出了4+1视图模型。它通过不同的视图，将系统分解，以简化问题。

| 视图名称 (View) | 核心关注点 (Keywords) | 描述内容 | 主要建模工具 | 面向人群 |
| :--- | :--- | :--- | :--- | :--- |
| **逻辑视图 (Logical View)** | **功能 (Functionality)** | 描述系统的功能需求，展示系统提供了哪些服务。主要关注对象和类之间的关系。 | 类图、对象图、状态图 | 设计师、开发者 |
| **开发视图 (Development View)** | **配置、装配、源代码** | 描述系统在开发环境下的静态组织结构，关注模块、包、构件和子系统。也称为实现视图。 | 包图、构件图 | 程序员、软件管理者 |
| **进程视图 (Process View)** | **并发、性能、可伸缩性、吞吐率** | 描述系统的动态行为，关注系统中的进程、线程、并发、同步和通信问题。 | 活动图、序列图 | 集成人员、性能工程师 |
| **物理视图 (Physical View)** | **拓扑、发布、安装** | 描述软件如何映射到硬件上，展示系统的物理拓扑结构和部署配置。也称为部署视图。 | 部署图 | 系统工程师、运维人员 |
| **场景视图 (Scenario View)** | **用例驱动 (Use Case-Driven)** | 处于核心地位，连接并验证其他四个视图。通过少量关键用例或场景，描述和驱动整个架构设计。 | 用例图、活动图 | 所有干系人 |

##### **2.2 基于架构的软件开发方法 (ABSD)**

ABSD (Architecture-Based Software Development) 是一种以架构为驱动的开发方法论。

*   **核心特征**：
    *   **架构驱动**：整个开发过程围绕架构展开（架构需求、设计、文档化、复审、实现、演化）。
    *   **需求驱动**：由**业务、质量和功能**三大需求组合驱动架构设计。
    *   **迭代与递归**：开发过程是递归、迭代的，允许在复审和演化阶段返回到早期阶段进行精化。

*   **三大基础**：
    1.  **功能分解 (Functional Decomposition)**：将系统功能分解到构件中。
    2.  **架构风格选定 (Style Selection)**：通过选择合适的架构风格来实现质量和业务需求。
    3.  **软件模板使用 (Use of Software Templates)**：利用现成模板加速开发。

*   **核心思想**：
    *   用**用例（Use Case）**捕获**功能需求**。
    *   用**特定场景（Scenario）**捕获**质量需求**（非功能需求）。

*   **ABSD开发过程详解**：
    1.  **架构需求 (Architecture Requirements)**
        *   **活动**: 需求获取、**标识构件**、需求评审。
        *   **特点**: 引入**需求库**以复用以往的需求分析成果。
        *   **标识构件步骤**:
            *   创建类图。
            *   对类进行分组。
            *   将类打包成构件。
    2.  **架构设计 (Architecture Design)**
        *   **活动**: 提出架构模型、**映射构件**、分析构件间相互作用、产生架构、设计评审。
        *   **区别**: “标识构件”是定义构件内部，“映射构件”是确定已有构件在系统中的位置和关系。
    3.  **架构文档化 (Architecture Documentation)**
        *   **目的**: 记录和传递架构设计，是架构成功的关键。
        *   **主要产出物**:
            *   **架构规格说明书** (Architecture Specification)
            *   **测试架构需求的质量设计说明书** (类似于测试计划)
        *   **文档化原则**: 从使用者角度编写、分发给所有相关人员、确保文档是最新版本。
    4.  **架构复审 (Architecture Review)**
        *   **目的**: 在项目早期评估架构，识别潜在风险。相当于**架构评估**。
    5.  **架构实现 (Architecture Implementation)**
        *   **活动**: 依托**构件库**进行分析、设计、实现和组装。
    6.  **架构演化 (Architecture Evolution)**
        *   **目的**: 应对系统上线后的需求变更和优化。
        *   **活动**: 需求变化归类、制定演化计划、更新构件、重新组装。

---

#### **第三章：核心软件架构风格**

架构风格是对一类特定架构的惯用模式的描述，它定义了构件词汇表和一组约束。

##### **3.1 数据流风格 (Data Flow)**

*   **核心思想**：系统被看作一系列数据处理步骤的组合。数据在构件之间流动，整个过程由数据驱动。
*   **优点**：松耦合、高内聚、可重用性好、支持并行。
*   **缺点**：交互性差，不适合处理交互密集的应用。
*   **典型实例**：传统编译器、网络报文处理。

*   **子风格对比**:

| 特性 | **批处理序列 (Batch Sequential)** | **管道和过滤器 (Pipes and Filters)** |
| :--- | :--- | :--- |
| **数据处理方式** | **整体处理**：将所有数据作为一个整体，处理完一步后，再完整传递给下一步。 | **流式处理**：数据以流的形式增量处理，一个构件处理完部分数据即可传递给下一构-件。 |
| **用户交互** | **几乎无交互**。 | **弱交互**，允许少量交互。 |
| **适用场景** | 大批量、非交互式的数据转换任务，如视频格式批量转换。 | 需要增量显示结果或具有一定交互性的数据处理，如流媒体播放（边下边看）。 |

##### **3.2 调用/返回风格 (Call and Return)**

*   **核心思想**：通过构件之间的显式调用和返回来组织系统，是目前最主流的风格。
*   **子风格**：
    *   **主程序/子程序**：传统的结构化编程思想。
    *   **面向对象风格**：通过对象之间的方法调用来协作。
    *   **分层风格 (Layered Style)**：
        *   **结构**：将系统组织成一个层次结构，每层为其上一层提供服务，并使用其下一层的服务。
        *   **约束**：严格分层中，某一层只能与相邻的层交互。
        *   **优点**：职责清晰、支持复用、降低耦合度、便于维护和扩展。
        *   **缺点**：并非所有系统都易于分层；可能会带来额外的性能开销。

##### **3.3 独立构件风格 (Independent Components)**

*   **核心思想**：构件之间不直接调用，而是通过**间接**的方式进行通信，以实现最大限度的解耦。
*   **优点**：耦合度极低、可修改性和可重用性强。
*   **缺点**：放弃了对系统计算的控制，正确性推理困难。
*   **子风格**：
    *   **进程通信**：通过消息传递等方式协作。
    *   **事件驱动系统 / 隐式调用 (Event-Driven / Implicit Invocation)**：
        *   **机制**：构件不直接调用其他构件，而是发布（广播）一个或多个**事件**。其他构件可以注册（监听）这些事件，并在事件发生时被自动触发执行。
        *   **核心组件**：事件源、事件管理器（消息队列、事件总线）、事件处理器。
        *   **典型模式**：发布/订阅模式 (Publish-Subscribe)。
        *   **应用场景**：图形用户界面（GUI）系统、现代IDE中的联动功能（如断点调试时，变量监视器自动刷新）。

##### **3.4 虚拟机风格 (Virtual Machine)**

*   **核心思想**：通过构建一个虚拟机（解释器或运行时环境），在底层平台之上提供一个抽象层。这使得软件可以独立于底层硬件和操作系统，增强了可移植性和灵活性。
*   **优点**：简化了目标代码，提高了可移植性（一次编写，到处运行），支持业务的灵活自定义。
*   **缺点**：可能会带来性能损失，因为多了一层解释/转换。
*   **典型实例**：Java虚拟机 (JVM)、工作流引擎、低代码平台。

*   **子风格对比**:

| 子风格 | **解释器 (Interpreter)** | **以规则为中心 (Rule-Based System)** |
| :--- | :--- | :--- |
| **核心组件** | 解释器引擎、被解释的程序（脚本）、程序当前状态。 | 规则解释器、**规则/知识库**、数据选择器、工作内存。 |
| **核心特征** | 提供一个引擎来解析和执行用特定语言编写的脚本或指令。 | 在解释器的基础上，**增加了知识库**，使系统能根据一组预定义的规则进行推理和决策。 |
| **适用场景** | 需要**自定义业务逻辑、规则或流程**的场景。例如：<br>- 大型多人游戏中的**自定义战役地图**。<br>- 工作流引擎。 | 需要基于专家知识进行**推理和决策**的场景。例如：<br>- **专家系统**。<br>- **语音识别**（作为黑板系统的一种实现方式）。 |

> **讲师提示**：以规则为中心的系统本质上是解释器风格的一种**增强版**或特例。在考试中，如果场景明确涉及**专家知识**或**推理决策**，应优先选择“以规则为中心”或其典型实现“**黑板系统**”。

##### **3.5 以数据为中心风格 (Data-Centered)**

*   **核心思想**：系统组件通过一个共享的中心数据存储（如数据库、黑板）进行交互。数据是系统的核心，组件对数据的操作是独立的。
*   **优点**：组件之间高度独立，易于添加新组件。
*   **缺点**：中心数据存储可能成为性能瓶颈和单点故障。
*   **子风格**：
    *   **仓库/数据库系统 (Repository/Database)**：最常见的形式，各种应用系统组件围绕一个共享数据库工作。例如：现代集成开发环境（IDE），其中编译器、调试器、编辑器等工具都围绕着同一份源代码工作。
    *   **黑板系统 (Blackboard System)**：
        *   **结构**：由**知识源 (Knowledge Sources)**、**黑板 (Blackboard)** 和**控制组件 (Control)** 三部分组成。
        *   **机制**：知识源响应黑板上数据的变化，对黑板进行修改，进而可能触发其他知识源。它是一种**机会主义**的解决问题模型。
        *   **关键特征**：数据（黑板）的变化会**主动触发**组件（知识源）的执行。
        *   **典型实例**：**语音识别**、信号处理、模式识别等需要解决不确定性问题的领域。
        > **考点记忆**：形成条件反射，"语音识别" 场景优先对应 **黑板系统**。

---

#### **第四章：其他重要架构风格**

##### **4.1 C2 风格**

*   **核心思想**：一种基于事件的风格，与分层风格相似。
*   **规则与约束**：
    *   构件和连接件都有一个**顶部 (Top)** 和一个**底部 (Bottom)**。
    *   构件的底部只能连接到连接件的顶部。
    *   连接件的底部可以连接到构件的顶部。
    *   **构件与构件之间不能直接相连**。
*   **应用**：学术研究为主，工业界应用较少。了解其基本特征即可。

##### **4.2 闭环控制 / 过程控制风格 (Closed-Loop / Process Control)**

*   **核心思想**：系统通过一个**反馈循环 (Feedback Loop)** 来持续调节自身行为，以达到或维持一个预设的目标状态。
*   **机制**：系统不断地**采集**外部环境数据，将其与**目标设定值 (Setpoint)** 进行比较，然后根据差值**调整**其输出。
*   **典型实例**：
    *   **家用空调自动调温**：持续测量室温，与设定温度比较，控制压缩机的启停。
    *   **汽车定速巡航**：持续监测车速，与设定速度比较，控制油门。
    *   **机器人控制**：根据自身状态和外界环境进行动态调整以完成任务。

---

#### **第五章：架构风格的识别与应用（考题场景汇总）**

| 场景描述 | 推荐风格 | 核心理由 |
| :--- | :--- | :--- |
| Java程序“一次编写，到处运行” | **虚拟机风格** | JVM作为虚拟机屏蔽了底层操作系统的差异。 |
| 网络通信中的包解析（包头分离->包文解析） | **数据流风格**（管道过滤器/批处理） | 数据（包）经过一系列连续的处理步骤。 |
| IDE调试器：设置断点后，编辑器和变量监视器自动响应 | **事件驱动风格**（隐式调用） | 断点是一个事件，触发了编辑器和监视器的联动响应，是典型的“牵一发而动全身”。 |
| 开发一个集成开发环境（IDE） | **以数据为中心风格** | 编译器、调试器等多种工具都围绕同一份核心数据（源代码）工作。 |
| 游戏支持玩家自行创建战役地图和定义对象行为 | **解释器风格** | “自定义”是关键词。地图和行为定义可被视为一种脚本，需要解释器来执行。 |
| 家用空调自动温度调节 | **过程控制风格** | 存在一个反馈循环：采集温度 -> 比较 -> 控制开关。 |
| 语音识别系统 | **黑板风格** | 这是最经典的考点对应关系。 |
| 火星探测机器人，可自定义任务和依赖关系 | **解释器风格**（优先） | “定义任务和时序依赖关系”是核心，指向解释器。虽然也涉及环境响应（过程控制/事件），但自定义任务的特征更突出。 |
| Windows操作系统的图形用户界面（GUI） | **事件驱动风格**（隐式调用） | 用户的鼠标点击、移动等都是事件，应用程序通过响应这些事件来工作。 |

---

#### **第六章：构件与中间件技术**

##### **6.1 构件 (Component) 的核心概念**

构件是构成软件系统的、具有复用价值的、标准化的组成部分。

*   **构件 vs. 对象 (Component vs. Object)**

| 特性 | **对象 (Object)** | **构件 (Component)** |
| :--- | :--- | :--- |
| **本质** | 类的**实例单元** | 系统的**部署单元** |
| **状态可见性** | **可能具有外部可见的状态**（如 `public` 属性） | **没有外部可见的状态**，所有状态和数据都必须通过标准接口方法访问。 |
| **组合方式** | 通过语言内的方法调用组合 | 可由**第三方**进行独立的组装和部署。 |
| **发布形式** | 通常与源代码一起 | 通常是二进制形式，可独立发布。 |

##### **6.2 构件的复用 (Component Reuse)**

复用是基于构件开发（CBD）的核心目的。

*   **构件的检索与提取 (Retrieval and Extraction)**
    1.  **基于关键字的检索 (Keyword-Based)**：通过树形或无回路图的分类体系进行查找。
    2.  **刻面检索法 (Faceted Classification)**：从多个**维度（切面）**对构件进行分类和检索，类似于面向方面编程（AOP）的思想。
    3.  **超文本检索法 (Hypertext-Based)**：在一个构件的文档中，通过超链接关联到其他相关构件，类似维基百科的词条链接。

*   **构件复用的过程**
    1.  **理解与评价 (Understanding and Evaluation)**：分析检索到的构件功能、接口、约束等，判断其是否满足当前需求。
    2.  **修改 (Modification)**：对不完全匹配的构件进行适应性修改。
    3.  **组装 (Assembly)**：将修改或适配后的构件相互连接，构成新的目标系统。


##### **6.3 中间件 (Middleware)**

*   **定义**：中间件是一种独立的系统软件或服务程序，位于操作系统和应用程序之间，或位于应用程序的不同部分之间。它本身是一种特殊的、标准化的构件。
*   **核心价值**：
    1.  **屏蔽底层差异**：隐藏不同操作系统和网络协议的复杂性，使应用开发更简单。
    2.  **简化系统结构**：将复杂的、多对多的连接关系简化为所有组件都与中间件连接的星型结构。
    3.  **提供标准服务**：提供通信、事务、安全、数据访问等通用服务，便于复用。
    4.  **实现应用解耦**：组件之间不直接通信，通过中间件交互，降低耦合度。

*   **中间件的分类**（新版教程分类）
    *   **通信处理/消息中间件 (MOM - Message-Oriented Middleware)**：负责高效、可靠的消息传递。
    *   **事务处理中间件 (TPM - Transaction Processing Middleware)**：确保事务的ACID特性，常用于负载均衡场景下的任务分配。
    *   **数据存取管理中间件**：提供对数据库的统一访问接口，如 **JDBC, ODBC**。
    *   **Web服务器中间件**：如 Tomcat, IIS 等。
    *   **安全中间件**：提供认证、授权、加密等安全服务。
    *   **跨平台中间件**、**专用平台中间件**等。

##### **6.4 构件技术标准**

构件技术需要遵循标准，以保证互操作性。

*   **三大主流标准**:
    1.  **CORBA (Common Object Request Broker Architecture)**
    2.  **EJB (Enterprise JavaBeans)**
    3.  **.NET 2000 (原DCOM/COM+)**

*   **CORBA 详解**:
    *   **定位**：一种跨语言、跨平台的**分布式对象技术**和中间件标准。
    *   **目的**：解决异构系统环境下，客户端如何透明地调用远程服务端对象的问题（远程过程调用 RPC 的一种实现）。
    *   **核心机制**：
        
        *   **客户端 (Client)**：发起请求。
        *   **对象引用 (Object Reference)**：客户端持有的远程对象的“代理”或“快捷方式”。
        *   **存根 (Stub)**：客户端的代理，将方法调用打包（编组）成网络消息。
        *   **对象请求代理 (ORB - Object Request Broker)**：核心组件，负责消息的传输、定位远程对象等。
        *   **对象适配器 (Object Adapter)**：服务端组件，负责接收请求，激活对象。
        *   **骨架 (Skeleton)**：服务端的代理，将接收到的网络消息解包（解组），并调用实际的对象实现。
        *   **伺服对象 (Servant)**：**真正的业务逻辑实现者**，负责完成客户端的请求。
    > **关键考点**：在CORBA模型中，**伺服对象(Servant)** 是真正实现业务逻辑、完成客户端请求的构件。

*   **EJB (Enterprise JavaBeans) 详解**:
    *   **定位**：Java平台下的服务端构件标准。
    *   **EJB构件分类 (Bean的类型)**:
        1.  **会话Bean (Session Bean)**：负责处理**业务逻辑**和流程控制。
        2.  **实体Bean (Entity Bean)**：负责**数据持久化**，代表数据库中的数据，实现对象-关系映射（O/R Mapping）。
        3.  **消息驱动Bean (Message-Driven Bean)**：负责处理**异步消息**，通常与消息中间件（如JMS）集成，实现并发处理。

---

#### **第七章：软件复用**

##### **7.1 复用的层次与历史**

软件复用是提高开发效率、降低成本、提升质量的关键手段。其复用的粒度在不断演进：
`函数库 -> 类库 -> 框架 -> 构件库 -> 服务库`

##### **7.2 复用的类型**

*   **按领域划分**:
    *   **水平复用 (Horizontal Reuse)**：**跨领域**的、通用的功能复用。例如：标准函数库、GUI窗体、按钮等。
    *   **垂直复用 (Vertical Reuse)**：**特定领域内**的专用功能复用。例如：医学影像分析模块、电子商务支付接口等。

*   **按策略划分**:
    *   **机会复用 (Opportunistic Reuse)**：**无规划的**、临时的复用。开发人员在过程中发现可复用的资产就拿来用，如代码的复制粘贴。
    *   **系统复用 (Systematic Reuse)**：**有规划的**、系统化的复用。在开发前就规划好哪些部分需要复用，并建立相应的构件库或产品线。

---

#### **第八章：特定领域软件架构 (DSSA)**

DSSA (Domain-Specific Software Architecture) 旨在通过在一个特定业务领域内建立通用的、可复用的架构，来支持该领域内一系列应用的快速开发。

##### **8.1 DSSA核心活动与产出物**

| 核心活动 | 目标 | 主要产出物 | 对应传统开发阶段 |
| :--- | :--- | :--- | :--- |
| **领域分析** | 寻找并定义领域内的**共性需求** | **领域模型** (Domain Model) | 需求分析 |
| **领域设计** | 基于领域模型，创建**共性架构** | **DSSA** (特定领域软件架构) | 软件设计 |
| **领域实现** | 开发出可复用的**共性构件/资产** | **构件库/核心资产库** | 软件实现 |

##### **8.2 DSSA参与人员**

*   **领域专家**：提供领域知识和建议，但不直接参与开发。是有经验的用户或资深工程师。
*   **领域分析师**：负责执行领域分析，建立领域模型。
*   **领域设计人员**：负责设计DSSA。
*   **领域实现人员**：负责开发领域内的可复用构件。
> **讲师提示**：领域开发人员通常比应用开发人员经验更丰富，因为他们开发的共性资产会影响多个产品，责任更重大。

##### **8.3 DSSA与软件产品线**

*   **关系**：DSSA是实现**软件产品线 (Software Product Line)** 的核心技术之一。
*   **软件产品线**：一种通过共享**核心资产库 (Core Asset Base)** 来系统化地开发一系列相关**产品集合 (Product Set)** 的方法。它综合运用了DSSA、领域工程和软件架构技术。

---

#### **第九章：软件架构评估**

架构评估是在项目早期对架构设计进行系统化评审，以识别潜在风险，确保架构能满足系统的质量需求。

##### **9.1 质量属性 (Quality Attributes)**

架构评估的重点是非功能性需求，即质量属性。考试中主要关注以下几类：

*   **性能 (Performance)**：系统的响应能力。
    *   **指标**: 响应时间、吞吐量、数据延迟、并发度。
    *   **场景**: "数据传递时延不大于1秒"。
    *   **战术**:
        *   **资源需求**: 提高计算效率（改进算法）、减少计算开销。
        *   **资源管理**: 引入并发、维护多副本（冗余）。
        *   **资源仲裁**: 采用调度策略（如先进先出、**优先级调度**）。

*   **可用性 (Availability)**：系统能够正常运行的时间比例。
    *   **指标**: 故障后恢复时间、MTBF（平均无故障时间）、7x24小时工作能力。
    *   **场景**: "主服务器故障，1分钟内切换到备用服务器"。
    *   **战术**:
        *   **错误检测**: **心跳 (Heartbeat)**、**Ping/Echo**。
        *   **错误恢复**: **冗余 (Redundancy)**（主动/被动）、表决。
        *   **错误预防**: 事务、移除故障服务。

*   **安全性 (Security)**：防止非授权访问和破坏。
    *   **指标**: 机密性、完整性、不可否认性、可控性。
    *   **场景**: "防止99%的黑客攻击"、"对所有操作都有完整记录（审计）"。
    *   **战术**:
        *   **抵抗攻击**: 身份验证、用户授权、加密。
        *   **检测攻击**: **入侵检测 (Intrusion Detection)**。
        *   **从攻击中恢复**: 冗余、**追踪审计**。

*   **可修改性 (Modifiability)**：对系统进行修改的难易程度。
    *   **指标**: 修改成本（如 "在4人月内完成"）。
    *   **场景**: "新功能开发不超过2人周"。
    *   **战术**:
        *   **局部化修改**: 高内聚、责任分离。
        *   **防止连锁反应**: 低耦合、**信息隐藏 (Information Hiding)**、使用接口。
        *   **推迟绑定时间**: **运行时注册**、配置文件、动态绑定。

##### **9.2 敏感点、权衡点与风险点**

*   **敏感点 (Sensitivity Point)**：**一个或多个构件**的某个特性，会显著**影响系统的单一质量属性**。
    *   **例子**: “数据处理协议的设计将影响系统的交易处理时间。” （多个构件影响单一属性：处理时间）
*   **权衡点 (Trade-off Point)**：一个影响**多个质量属性**的特性，通常这些属性之间存在冲突。
    *   **例子**: “更改加密级别将影响系统的**安全性和性能**。”
*   **风险点 (Risk Point)**：架构设计中存在的、可能导致问题的**潜在隐患或不确定性**。
    *   **例子**: “对信用卡支付业务逻辑的描述**尚未达成共识**，可能导致模块重复开发。”
*   **非风险点 (Non-Risk Point)**：经过分析确认，某个设计决策**不会**带来隐患。
    *   **例子**: “根据计算，每秒10个请求，每个30ms，在一秒钟内完成是**可以实现的**。”

##### **9.3 架构评估方法**

*   **基于场景的评估 (Scenario-Based)**：最常用、最重要的方法。通过具体场景来分析和评估架构。
    *   **场景的六个组成部分**:
        1.  **刺激源 (Source of Stimulus)**
        2.  **刺激 (Stimulus)**
        3.  **制品 (Artifact)**：被刺激的系统部分
        4.  **环境 (Environment)**
        5.  **响应 (Response)**
        6.  **响应度量 (Response Measure)**
    *   **两种重要方法**:
        *   **SAAM (Software Architecture Analysis Method)**：早期的评估方法，最初只关注**可修改性**，后扩展到其他属性。
        *   **ATAM (Architecture Trade-off Analysis Method)**：在SAAM基础上发展而来，更全面，明确关注**性能、可用性、安全性和可修改性**四大属性，并引入**质量属性效用树 (Utility Tree)** 和**权衡分析**。
            *   **ATAM四个阶段**: 场景和需求收集 -> 架构视图和场景实现 -> 属性模型分析与构建 -> 权衡。
